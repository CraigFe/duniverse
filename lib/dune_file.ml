open Stdune

module Lang = struct
  type version = int * int

  let compare_version (major, minor) (major', minor') =
    match Int.compare major major' with Eq -> Int.compare minor minor' | _ as ord -> ord

  let pp_version fmt (major, minor) = Format.fprintf fmt "%d.%d" major minor

  let parse_version s =
    let err () = Error (`Msg (Printf.sprintf "Invalid dune lang version: %s" s)) in
    match String.split ~on:'.' s with
    | [ major; minor ] -> (
        match (Int.of_string major, Int.of_string minor) with
        | Some major, Some minor -> Ok (major, minor)
        | _ -> err () )
    | _ -> err ()

  let parse_stanza s =
    let content =
      let open Option.O in
      String.drop_prefix ~prefix:"(" s >>= String.drop_suffix ~suffix:")" >>| fun content ->
      String.split ~on:' ' content
    in
    match content with
    | Some [ "lang"; "dune"; version ] -> parse_version version
    | _ -> Error (`Msg (Printf.sprintf "Invalid lang stanza: %s" s))

  let is_stanza s = String.is_prefix ~prefix:"(lang " s

  let duniverse_minimum_version = (2,0)

  let stanza version = Format.asprintf "(lang dune %a)" pp_version version
end

module Raw = struct
  let comment s = Printf.sprintf "; %s" s

  let vendored_dirs glob = Printf.sprintf "(vendored_dirs %s)" glob

  let duniverse_dune_content =
    [
      comment "This file is generated by duniverse.";
      comment "Be aware that it is likely to be overwritten by your next duniverse pull invocation.";
      "";
      vendored_dirs "*";
    ]

  let duniverse_minimum_lang = Lang.stanza Lang.duniverse_minimum_version
end

module Workspace = struct

  let load_dune_workspace () =
    match Sexplib.Sexp.load_sexps "dune-workspace" with
    | v -> Ok v
    | exception exn -> Error (`Msg (Printexc.to_string exn))

  let dune_workspace_header () =
    Sexplib.Sexp.(List [ Atom "lang"; Atom "dune"; Atom "2.5" ])

  let path_frag =
    let open Sexplib.Sexp in
    let bootstrap_dir = Fpath.to_string (Config.bootstrap_bin_dir) in
    [ Atom "PATH"; Atom bootstrap_dir; Atom ":standard" ]

  let default_dune_workspace () =
    let open Sexplib.Sexp in
    List [ Atom "context";
      List [ Atom "default";
        List [ Atom "paths"; List path_frag ] ] ]

  let update_dune_version =
    let open Sexplib.Sexp in
    function
    | (List [ Atom "lang"; Atom "dune"; Atom v ] :: tl) as l -> begin
        match Ordering.of_int (OpamVersionCompare.compare v "2.0") with
        | Gt | Eq -> l
        | Lt -> List [ Atom "lang"; Atom "dune"; Atom "2.0" ] :: tl
    end
    | v -> v

  let update_default_dune_context l =
    let bootstrap_dir = Fpath.to_string (Config.bootstrap_bin_dir) in
    let open Sexplib.Sexp in
    (* List [Atom "PATH"; Sexplib.Sexp.Atom "_ocaml/bin"; Atom ":standard"] *)
    let update_PATH_entry l =
      match l with
      | List (Atom "PATH" :: paths) ->
         let l =
           if List.exists ~f:(fun e -> e = Atom bootstrap_dir) paths then Atom "PATH" :: paths else
           (Atom "PATH") :: (Atom bootstrap_dir) :: paths
         in
         if List.exists ~f:(fun e -> e = Atom ":standard") l then List l else
         List (l @ [ Atom ":standard"])
      | _ -> l
    in
    let add_PATH_entry =
      List [ Atom "PATH"; Atom bootstrap_dir; Atom ":standard" ]
    in
    (*      List [Atom "paths";
     *        List [Atom "BARPATH"; Sexplib.Sexp.Atom "_x/y"];
     *        List [Atom "PATH"; Sexplib.Sexp.Atom "_ocaml/bin"; Atom ":standard"]]]];
     *)
    let update_paths_entry l =
      match l with
      | List (Atom "paths" :: paths) ->
          if List.exists ~f:(function List (Atom "PATH"::_) -> true |_ -> false) paths then
            List (Atom "paths" :: (List.map ~f:update_PATH_entry paths))
          else
            List (Atom "paths" :: (add_PATH_entry :: paths))
      | v -> v
    in
    let add_paths_entry = List [ Atom "paths"; add_PATH_entry ] in
    (*  List [Atom "default";
     *        List [Atom "root"; Atom "_ocaml/.opam"];
     *        List [
     *          Atom "paths";
     *          List [Atom "BARPATH"; Atom "_x/y"];
     *          List [Atom "PATH"; Atom "_ocaml/bin"; Atom ":standard"]]]] *)
    let find_or_update_paths_entry l =
      match l with
      | List (Atom "default" :: fields) -> begin
          if List.exists ~f:(function List ( Atom "paths" :: _ ) -> true | _ -> false) fields then
              List (Atom "default" :: (List.map ~f:update_paths_entry fields))
          else
              List (Atom "default" :: (add_paths_entry :: fields))
      end
      | v -> v
    in
    List.map ~f:(function
      | List (Atom "context" :: fields) ->
          List (Atom "context" :: (List.map ~f:find_or_update_paths_entry fields))
      | v -> v) l

  let update_default_dune_contexts =
    let open Sexplib.Sexp in
     function
     | ver::tl ->
        let has_default_context =
          List.exists ~f:(function List [Atom "context";
            List (Atom "default"::_) ] -> true | _ -> false) tl in
        if has_default_context then
          ver :: (update_default_dune_context tl)
        else
          ver :: (tl @ [default_dune_workspace ()])
     | [] -> []

  let update_workspace_paths () =
    match load_dune_workspace () with
    | Error _ ->
       Logs.app (fun l -> l "Creating dune-workspace file to use local tools");
       Ok [dune_workspace_header (); default_dune_workspace ()]
    | Ok s -> begin
       update_dune_version s |> fun s ->
       Ok (update_default_dune_contexts s)
    end
     
end

module Project = struct
  module OV = Ocaml_version

  let load_dune_project () =
    match Sexplib.Sexp.load_sexps "dune-project" with
    | v -> Ok v
    | exception exn -> Error (`Msg (Printexc.to_string exn))

  let check_opam_generation =
    let open Sexplib.Sexp in
    List.exists ~f:(function
      | List [ Atom "generate_opam_files"; Atom "true" ] -> true
      | _ -> false)

  let compare_ov a b op =
    let b = OV.of_string_exn b in
    match (OV.compare a b, op) with
    | -1, ("<=" | "<" | "<>") -> true
    | 0, ("<=" | "=" | ">=") -> true
    | 0, "<>" -> false
    | 1, (">=" | ">" | "<>") -> true
    | _ -> false

  let eval_ocaml_bcomp sxp ov =
    let open Sexplib.Sexp in
    let rec eval = function
      | List (Atom "and" :: tl) -> List.fold_left ~f:(fun a b -> eval b && a) ~init:true tl
      | List (Atom "or" :: tl) -> List.fold_left ~f:(fun a b -> eval b || a) ~init:false tl
      | List [ Atom "not"; a ] -> not (eval a)
      | List [ Atom ((">=" | ">" | "=" | "<" | "<=" | "<>") as op); Atom a ] -> compare_ov ov a op
      | List _ -> failwith "unexpected list atoms, only ne/and/or/not supported"
      | Atom _ -> true
    in
    eval sxp

  let supported_ocaml_compilers () =
    let open Result.O in
    let open Sexplib.Sexp in
    load_dune_project () >>= fun sxp ->
    (* Check that opam file generation is on, and warn otherwise *)
    match check_opam_generation sxp with
    | false ->
        Error
          (`Msg
            "Duniverse requires you to have (generate_opam_files true) in your dune-project, so \
             that it can infer the supported OCaml versions from your package constraints. Please \
             see https://dune.readthedocs.io/en/stable/opam.html#generating-opam-files")
    | true ->
        let constr =
          List.filter_map
            ~f:(function
              | List (Atom "package" :: prsxp) -> (
                  List.filter_map
                    ~f:(function List (Atom "depends" :: depsxp) -> Some depsxp | _ -> None)
                    prsxp
                  |> function
                  | [] -> None
                  | depsxp :: _ -> (
                      List.filter_map
                        ~f:(function
                          | Atom "ocaml" -> Some []
                          | List (Atom "ocaml" :: ocsxp) -> Some ocsxp
                          | _ -> None)
                        depsxp
                      |> function
                      | [] -> None
                      | res :: _ -> Some res ) )
              | _ -> None)
            sxp
          |> List.flatten
        in
        let constr = List (Atom "and" :: constr) in
        let r =
          List.filter ~f:(eval_ocaml_bcomp constr) OV.Releases.all
        in
        Ok r
end
